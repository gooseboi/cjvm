#![deny(
    clippy::enum_glob_use,
    clippy::pedantic,
    clippy::nursery,
    clippy::unwrap_used
)]

// Useful links:
// Jar file spec: https://docs.oracle.com/en/java/javase/20/docs/specs/jar/jar.html
// Class file spec: https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html

use camino::Utf8PathBuf;
use clap::Parser as _;
use rc_zip_sync::ReadZip;
use std::{
    collections::HashMap,
    fs::File,
    io::{Cursor, Read},
};

#[derive(clap::Parser)]
struct Cmd {
    #[arg()]
    fname: Utf8PathBuf,
}

fn parse_manifest(manifest: &str) -> HashMap<String, String> {
    manifest
        .lines()
        .filter_map(|s| s.split_once(':'))
        .map(|(s1, s2)| (s1.into(), s2.trim().into()))
        .collect()
}

bitflags::bitflags! {
    /// Table 4.1. Class access and property modifiers
    /// | Flag Name        | Value  | Interpretation                                                                     |
    /// | ---------------- | ------ | ---------------------------------------------------------------------------------- |
    /// | `ACC_PUBLIC`     | 0x0001 | Declared public; may be accessed from outside its package.                        |
    /// | `ACC_FINAL`      | 0x0010 | Declared final; no subclasses allowed.                                            |
    /// | `ACC_SUPER`      | 0x0020 | Treat superclass methods specially when invoked by the invokespecial instruction. |
    /// | `ACC_INTERFACE`  | 0x0200 | Is an interface, not a class.                                                     |
    /// | `ACC_ABSTRACT`   | 0x0400 | Declared abstract; must not be instantiated.                                      |
    /// | `ACC_SYNTHETIC`  | 0x1000 | Declared synthetic; not present in the source code.                               |
    /// | `ACC_ANNOTATION` | 0x2000 | Declared as an annotation type.                                                   |
    /// | `ACC_ENUM`       | 0x4000 | Declared as an enum type.                                                         |
    ///
    /// A class may be marked with the [`ClassAccessFlags::Synthetic`] flag to indicate that it was generated by a
    /// compiler and does not appear in source code.
    ///
    /// The [`ClassAccessFlags::Enum`] flag indicates that this class or its superclass is declared as an
    /// enumerated type.
    ///
    /// An interface is distinguished by its [`ClassAccessFlags::Interface`] flag being set. If its [`ClassAccessFlags::Interface`]
    /// flag is not set, this class file defines a class, not an interface.
    ///
    /// If the [`ClassAccessFlags::Interface`] flag of this class file is set, its [`ClassAccessFlags::Abstract`] flag must also be
    /// set (JLS §9.1.1.1). Such a class file must not have its [`ClassAccessFlags::Final`], [`ClassAccessFlags::Super`] or
    /// [`ClassAccessFlags::Enum`] flags set.
    ///
    /// An annotation type must have its [`ClassAccessFlags::Annotation`] flag set. If the [`ClassAccessFlags::Annotation`] flag is
    /// set, the [`ClassAccessFlags::Interface`] flag must be set as well. If the [`ClassAccessFlags::Interface`] flag of this
    /// class file is not set, it may have any of the other flags in Table 4.1 set, except the
    /// [`ClassAccessFlags::Annotation`] flag. However, such a class file cannot have both its [`ClassAccessFlags::Final`] and
    /// [`ClassAccessFlags::Abstract`] flags set (JLS §8.1.1.2).
    ///
    /// The [`ClassAccessFlags::Super`] flag indicates which of two alternative semantics is to be expressed by the
    /// invokespecial instruction (§invokespecial) if it appears in this class. Compilers to the
    /// instruction set of the Java Virtual Machine should set the [`ClassAccessFlags::Super`] flag.
    ///
    /// The [`ClassAccessFlags::Super`] flag exists for backward compatibility with code compiled by older compilers
    /// for the Java programming language. In Oracle’s JDK prior to release 1.0.2, the compiler
    /// generated [`ClassFile::access_flags`] in which the flag now representing [`ClassAccessFlags::Super`] had no
    /// assigned meaning, and Oracle's Java Virtual Machine implementation ignored the flag if it
    /// was set.
    ///
    /// All bits of the [`ClassFile::access_flags`] item not assigned in Table 4.1 are reserved for future
    /// use. They should be set to zero in generated class files and should be ignored by Java
    /// Virtual Machine implementations.
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    struct ClassAccessFlags: u16 {
        ///Declared public; may be accessed from outside its package.
        const Public = 0x0001;
        /// Declared final; no subclasses allowed.
        const Final = 0x0010;
        ///Treat superclass methods specially when invoked by the invokespecial instruction.
        const Super = 0x0020;
        /// Is an interface, not a class.
        const Interface = 0x0200;
        /// Declared abstract; must not be instantiated.
        const Abstract = 0x0400;
        ///  Declared synthetic; not present in the source code.
        const Synthetic = 0x1000 ;
        /// Declared as an annotation type.
        const Annotation = 0x2000;
        /// Declared as an enum type.
        const Enum = 0x4000;
    }
}

bitflags::bitflags! {
    /// The value of the access_flags item is a mask of flags used to denote access permission to
    /// and properties of this method. The interpretation of each flag, when set, is as shown in
    /// Table 4.5.
    ///
    /// Table 4.5. Method access and property flags
    /// | Flag Name        | Value 	| Interpretation                                                 |
    /// | ---------------- | ------ | -------------------------------------------------------------- |
    /// | ACC_PUBLIC       | 0x0001 | Declared public; may be accessed from outside its package.     |
    /// | ACC_PRIVATE      | 0x0002 | Declared private; accessible only within the defining class.   |
    /// | ACC_PROTECTED    | 0x0004 | Declared protected; may be accessed within subclasses.         |
    /// | ACC_STATIC       | 0x0008 | Declared static.                                               |
    /// | ACC_FINAL        | 0x0010 | Declared final; must not be overridden (§5.4.5).               |
    /// | ACC_SYNCHRONIZED | 0x0020 | Declared synchronized; invocation is wrapped by a monitor use. |
    /// | ACC_BRIDGE       | 0x0040 | A bridge method, generated by the compiler.                    |
    /// | ACC_VARARGS      | 0x0080 | Declared with variable number of arguments.                    |
    /// | ACC_NATIVE       | 0x0100 | Declared native; implemented in a language other than Java.    |
    /// | ACC_ABSTRACT     | 0x0400 | Declared abstract; no implementation is provided.              |
    /// | ACC_STRICT       | 0x0800 | Declared strictfp; floating-point mode is FP-strict.           |
    /// | ACC_SYNTHETIC    | 0x1000 | Declared synthetic; not present in the source code.            |
    ///
    /// The [`MethodAccessFlags::VarArgs`] flag indicates that this method takes a variable number
    /// of arguments at the source code level. A method declared to take a variable number of
    /// arguments must be compiled with the [`MethodAccessFlags::VarArgs`] flag set to 1. All other
    /// methods must be compiled with the [`MethodAccessFlags::VarArgs`] flag set to 0.
    ///
    /// The [`MethodAccessFlags::Bridge`] flag is used to indicate a bridge method generated by a
    /// Java compiler.
    ///
    /// A method may be marked with the [`MethodAccessFlags::Synthetic`] flag to indicate that it
    /// was generated by a compiler and does not appear in source code, unless it is one of the
    /// methods named in §4.7.8.
    ///
    /// Methods of classes may set any of the flags in Table 4.5. However, a specific method of a
    /// class may have at most one of its [`MethodAccessFlags::Private`],
    /// [`MethodAccessFlags::Protected`] and [`MethodAccessFlags::Public`] flags set (JLS
    /// §8.4.3). If a specific method has its [`MethodAccessFlags::Abstract`] flag set, it must not have any of its
    /// [`MethodAccessFlags::Final`], [`MethodAccessFlags::Native`], [`MethodAccessFlags::Private`], [`MethodAccessFlags::Static`],
    /// [`MethodAccessFlags::Strict`] or [`MethodAccessFlags::Synchronized`] flags set (JLS
    /// §8.4.3.1, JLS §8.4.3.3, JLS §8.4.3.4).
    ///
    /// All interface methods must have their [`MethodAccessFlags::Abstract`] and [`MethodAccessFlags::Public`] flags
    /// set; they may have their [`MethodAccessFlags::VarArgs`], [`MethodAccessFlags::Bridge`] and
    /// [`MethodAccessFlags::Synthetic`] flags set and must not have any of the other flags in
    /// Table 4.5 set (JLS §9.4).
    ///
    /// A specific instance initialization method (§2.9) may have at most one of its
    /// [`MethodAccessFlags::Private`], [`MethodAccessFlags::Protected`], and
    /// [`MethodAccessFlags::Public`] flags set, and may also have its
    /// [`MethodAccessFlags::Strict`], [`MethodAccessFlags::VarArgs`] and
    /// [`MethodAccessFlags::Synthetic`] flags set, but must not have any of the other flags in
    /// Table 4.5 set.
    ///
    /// Class and interface initialization methods (§2.9) are called implicitly by the Java Virtual
    /// Machine. The value of their access_flags item is ignored except for the setting of the
    /// [`MethodAccessFlags::Strict`] flag.
    ///
    /// All bits of the access_flags item not assigned in Table 4.5 are reserved for future
    /// use. They should be set to zero in generated class files and should be ignored by Java
    /// Virtual Machine implementations.
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    struct MethodAccessFlags: u16 {
        /// Declared public; may be accessed from outside its package.
        const Public = 0x0001;
        /// Declared private; accessible only within the defining class.
        const Private = 0x0002;
        /// Declared protected; may be accessed within subclasses.
        const Protected = 0x0004;
        /// Declared static.
        const Static = 0x0008;
        /// Declared final; must not be overridden (§5.4.5).
        const Final = 0x0010;
        /// Declared synchronized; invocation is wrapped by a monitor use.
        const Synchronized = 0x0020;
        /// A bridge method, generated by the compiler.
        const Bridge = 0x0040;
        /// Declared with variable number of arguments.
        const VarArgs = 0x0080;
        /// Declared native; implemented in a language other than Java.
        const Native = 0x0100;
        /// Declared abstract; no implementation is provided.
        const Abstract = 0x0400;
        /// Declared strictfp; floating-point mode is FP-strict.
        const Strict = 0x0800;
        /// Declared synthetic; not present in the source code.
        const Synthetic = 0x1000;
    }
}

impl ConstantPoolInfo {
    fn parse(buf: &mut Cursor<&[u8]>) -> Self {
        let tag = read_u8_be(buf);
        match tag {
            // Utf8
            1 => {
                let length = read_u16_be(buf).into();
                let mut bytes = vec![0; length];
                buf.read_exact(&mut bytes).expect("it's a cursor");
                let str =
                    String::from_utf8(bytes).expect("TODO: parse whatever the fuck strings are");

                Self::Utf8 { bytes: str }
            }
            // Integer
            3 => Self::Integer {
                bytes: read_u32_be(buf),
            },
            // Float
            4 => Self::Float {
                bytes: read_f32_be(buf),
            },
            // Long
            5 => Self::Long {
                bytes: read_u64_be(buf),
            },
            // Double
            6 => Self::Double {
                bytes: read_f64_be(buf),
            },
            // Class
            7 => Self::Class {
                name_index: read_u16_be(buf),
            },
            // String
            8 => Self::String {
                string_index: read_u16_be(buf),
            },
            // Fieldref
            9 => {
                let class_index = read_u16_be(buf);
                let name_and_type_index = read_u16_be(buf);
                Self::Fieldref {
                    class_index,
                    name_and_type_index,
                }
            }
            // Methodref
            10 => {
                let class_index = read_u16_be(buf);
                let name_and_type_index = read_u16_be(buf);
                Self::Methodref {
                    class_index,
                    name_and_type_index,
                }
            }
            // InterfaceMethodref
            11 => todo!(),
            // NameAndType
            12 => {
                let name_index = read_u16_be(buf);
                let descriptor_index = read_u16_be(buf);
                Self::NameAndType {
                    name_index,
                    descriptor_index,
                }
            }
            // MethodHandle
            15 => todo!(),
            // MethodType
            16 => todo!(),
            // InvokeDynamic
            18 => todo!(),
            _ => panic!("invalid tag {tag}"),
        }
    }
}

#[derive(Debug, Clone)]
enum ConstantPoolInfo {
    Utf8 {
        bytes: String,
    },
    Integer {
        bytes: u32,
    },
    Float {
        bytes: f32,
    },
    Long {
        bytes: u64,
    },
    Double {
        bytes: f64,
    },

    /// The `CONSTANT_Class_info` structure is used to represent a class or an interface.
    Class {
        /// The value of the [`ConstantPoolInfo::Class::name_index`] item must be a valid index into the [`ClassFile::constant_pool`]
        /// table. The [`ClassFile::constant_pool`] entry at that index must be a [`ConstantPoolInfo::Utf8`] (§4.4.7)
        /// structure representing a valid binary class or interface name encoded in internal form
        /// (§4.2.1).
        name_index: u16,
    },
    String {
        string_index: u16,
    },

    /// Fields, methods, and interface methods are represented by similar structures.
    Fieldref {
        /// The value of the [`ConstantPoolInfo::Fieldref::class_index`] item must be a valid index
        /// into the [`ClassFile::constant_pool`] table. The [`ClassFile::constant_pool`] entry at
        /// that index must be a [`ConstantPoolInfo::Class`] (§4.4.1) structure representing a
        /// class or interface type that has the field or method as a member.
        ///
        /// The [`ConstantPoolInfo::Fieldref::class_index`] item of a
        /// [`ConstantPoolInfo::Fieldref`] structure may be either a class type or an interface
        /// type.
        class_index: u16,

        /// The value of the [`ConstantPoolInfo::Fieldref::name_and_type_index`] item must be a
        /// valid index into the [`ClassFile::constant_pool`] table. The
        /// [`ClassFile::constant_pool`] entry at that index must be a [`ConstantPoolInfo::NameAndType`]
        /// (§4.4.6) structure. This [`ClassFile::constant_pool`] entry indicates the name and
        /// descriptor of the field or method.
        name_and_type_index: u16,
    },
    Methodref {
        class_index: u16,
        name_and_type_index: u16,
    },
    InterfaceMethodref,
    NameAndType {
        name_index: u16,
        descriptor_index: u16,
    },
    MethodHandle,
    MethodType,
    InvokeDynamic,
}

#[derive(Debug, Clone)]
struct FieldInfo {}

#[derive(Debug, Clone)]
struct MethodInfo {
    access_flags: MethodAccessFlags,
    name_index: u16,
    descriptor_index: u16,
}

#[derive(Debug, Clone)]
struct AttributeInfo {}

/// The contents of a `.class` file.
///
/// The docs are mostly from
/// <https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html#jvms-4.1/>
#[derive(Debug, Clone)]
struct ClassFile {
    /// The magic item supplies the magic number identifying the class file format; it has the
    /// value 0xCAFEBABE.
    magic: u32,

    /// The values of the [`ClassFile::minor_version`] and [`ClassFile::major_version`] items are the minor and major version
    /// numbers of this class file. Together, a major and a minor version number determine the
    /// version of the class file format. If a class file has major version number M and minor
    /// version number m, we denote the version of its class file format as M.m. Thus, class file
    /// format versions may be ordered lexicographically, for example, 1.5 < 2.0 < 2.1.
    minor_version: u16,

    /// Refer to [`ClassFile::minor_version`] docs.
    major_version: u16,

    /// The value of the `constant_pool_count` item is equal to the number of entries in the
    /// [`ClassFile::constant_pool`] table plus one. A [`ClassFile::constant_pool`] index is considered valid if it is greater
    /// than zero and less than `constant_pool_count`, with the exception for constants of type long
    /// and double noted in §4.4.5.
    ///
    /// The length is u16.
    ///
    /// The [`ClassFile::constant_pool`] is a table of structures (§4.4) representing various string constants,
    /// class and interface names, field names, and other constants that are referred to within the
    /// [`ClassFile`] structure and its substructures. The format of each [`ClassFile::constant_pool`] table entry is
    /// indicated by its first "tag" byte.
    /// The [`ClassFile::constant_pool`] table is indexed from 1 to `constant_pool_count-1`.
    constant_pool: Vec<ConstantPoolInfo>,

    /// The value of the [`ClassFile::access_flags`] item is a mask of flags used to denote access permissions to
    /// and properties of this class or interface. The interpretation of each flag, when set, is as
    /// shown in Table 4.1.
    access_flags: ClassAccessFlags,

    /// The value of the `this_class` item must be a valid index into the [`ClassFile::constant_pool`] table. The
    /// [`ClassFile::constant_pool`] entry at that index must be a `CONSTANT_Class_info` structure
    /// representing the class or interface defined by this class file.
    this_class: u16,

    /// For a class, the value of the [`ClassFile::super_class`] item either must be zero or must be a valid index
    /// into the [`ClassFile::constant_pool`] table. If the value of the [`ClassFile::super_class`] item is nonzero, the
    /// [`ClassFile::constant_pool`] entry at that index must be a `CONSTANT_Class_info` structure
    /// representing the direct superclass of the class defined by this class file. Neither the
    /// direct superclass nor any of its superclasses may have the [`ClassAccessFlags::Final`] flag set in the
    /// [`ClassFile::access_flags`] item of its [`ClassFile`] structure.
    ///
    /// If the value of the [`ClassFile::super_class`] item is zero, then this class file must represent the class
    /// Object, the only class or interface without a direct superclass.
    ///
    /// For an interface, the value of the [`ClassFile::super_class`] item must always be a valid index into the
    /// [`ClassFile::constant_pool`] table. The [`ClassFile::constant_pool`] entry at that index
    /// must be a `CONSTANT_Class_info` structure representing the class Object.
    super_class: u16,

    /// The value of the `interfaces_count` item gives the number of direct superinterfaces of this
    /// class or interface type.
    ///
    /// Each value in the interfaces array must be a valid index into the [`ClassFile::constant_pool`] table. The
    /// [`ClassFile::constant_pool`] entry at each value of interfaces\[i\], where 0 ≤ i < `interfaces_count`, must be
    /// a `CONSTANT_Class_info` structure (§4.4.1) representing an interface that is a direct
    /// superinterface of this class or interface type, in the left-to-right order given in the
    /// source for the type.
    interfaces: Vec<u16>,

    /// The value of the `fields_count` item gives the number of [`FieldInfo`] structures in the
    /// [`ClassFile::fields`] table. The [`FieldInfo`] structures (§4.5) represent all fields, both
    /// class variables and instance variables, declared by this class or interface type.
    ///
    /// Each value in the fields table must be a [`FieldInfo`] (§4.5) structure giving a complete
    /// description of a field in this class or interface. The fields table includes only those
    /// fields that are declared by this class or interface. It does not include items representing
    /// fields that are inherited from superclasses or superinterfaces.
    fields: Vec<FieldInfo>,

    /// The value of the `methods_count` item gives the number of [`MethodInfo`] structures in the
    /// methods table.
    ///
    /// Each value in the methods table must be a [`MethodInfo`] (§4.6) structure giving a complete
    /// description of a method in this class or interface. If neither of the
    /// [`MethodAccessFlags::Native`] and [`MethodAccessFlags::Abstract`] flags are set in the
    /// [`MethodInfo::access_flags`] item of a [`MethodInfo`] structure, the Java Virtual Machine
    /// instructions implementing the method are also supplied.
    ///
    /// The [`MethodInfo`] structures represent all methods declared by this class or interface
    /// type, including instance methods, class methods, instance initialization methods (§2.9),
    /// and any class or interface initialization method (§2.9). The methods table does not include
    /// items representing methods that are inherited from superclasses or superinterfaces.
    methods: Vec<MethodInfo>,

    attributes: Vec<AttributeInfo>,
}

fn read_u8_be(buf: &mut Cursor<&[u8]>) -> u8 {
    let mut tmp = [0u8; 1];
    buf.read_exact(&mut tmp).expect("it's a cursor");
    u8::from_be_bytes(tmp)
}

fn read_u16_be(buf: &mut Cursor<&[u8]>) -> u16 {
    let mut tmp = [0u8; 2];
    buf.read_exact(&mut tmp).expect("it's a cursor");
    u16::from_be_bytes(tmp)
}

fn read_u32_be(buf: &mut Cursor<&[u8]>) -> u32 {
    let mut tmp = [0u8; 4];
    buf.read_exact(&mut tmp).expect("it's a cursor");
    u32::from_be_bytes(tmp)
}

fn read_u64_be(buf: &mut Cursor<&[u8]>) -> u64 {
    let mut tmp = [0u8; 8];
    buf.read_exact(&mut tmp).expect("it's a cursor");
    u64::from_be_bytes(tmp)
}

fn read_f32_be(buf: &mut Cursor<&[u8]>) -> f32 {
    let mut tmp = [0u8; 4];
    buf.read_exact(&mut tmp).expect("it's a cursor");
    f32::from_be_bytes(tmp)
}

fn read_f64_be(buf: &mut Cursor<&[u8]>) -> f64 {
    let mut tmp = [0u8; 8];
    buf.read_exact(&mut tmp).expect("it's a cursor");
    f64::from_be_bytes(tmp)
}

fn parse_class_file(class_file: &[u8]) -> ClassFile {
    let mut reader = Cursor::new(class_file);
    let magic = read_u32_be(&mut reader);
    println!("Magic: {magic:x}");

    let minor_version = read_u16_be(&mut reader);
    let major_version = read_u16_be(&mut reader);
    println!("Version {major_version}.{minor_version}");

    let constant_pool_count = read_u16_be(&mut reader);
    let mut constant_pool = Vec::with_capacity(constant_pool_count.into());
    println!("There are {constant_pool_count} constants");

    for i in 0..constant_pool_count {
        let info = ConstantPoolInfo::parse(&mut reader);
        println!("{i}: Found {info:?}");
        constant_pool.push(info);
    }

    ClassFile {
        magic,
        minor_version,
        major_version,
        constant_pool,
        access_flags: todo!(),
        this_class: todo!(),
        super_class: todo!(),
        interfaces: todo!(),
        fields: todo!(),
        methods: todo!(),
        attributes: todo!(),
    }
}

fn main() {
    let cmd = Cmd::parse();
    let file = File::options()
        .read(true)
        .write(false)
        .open(cmd.fname)
        .expect("failed opening jar file");

    let zip = file
        .read_zip()
        .expect("file should be a jar file (a zip file)");

    let entry = zip
        .by_name("META-INF/MANIFEST.MF")
        .expect("there should be a manifest file");

    let manifest = entry.bytes().expect("should be able to read out manifest");
    let manifest = str::from_utf8(&manifest).expect("manifest is UTF-8 text");
    let manifest = parse_manifest(manifest);
    println!("Parsed manifest");

    if manifest
        .get("Manifest-Version")
        .expect("manifest should have a version")
        != "1.0"
    {
        panic!("Only manifest version supported is 1.0");
    }

    let main_class_name = manifest
        .get("Main-Class")
        .expect("Jar can't be compiled down without main class");
    println!("Main class is {main_class_name}");

    let mut main_class_path = main_class_name.replace('.', "/");
    main_class_path.push_str(".class");
    let main_class = zip
        .by_name(main_class_path)
        .expect("main class should be in jar");
    let main_class = main_class
        .bytes()
        .expect("should be able to read out main_class");

    println!("main class is {} bytes long", main_class.len());

    let main_class = parse_class_file(&main_class);
    println!("{main_class:?}");

    println!();
    println!("All entries: ");
    for entry in zip.entries() {
        if entry.uncompressed_size == 0 {
            // It's a directory
            continue;
        }

        println!("{}:{}", entry.uncompressed_size, entry.name);
    }
}
