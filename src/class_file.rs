// Class file spec: https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html

use crate::utils::{
    read_exact_bytes, read_f32_be, read_f64_be, read_u8_be, read_u16_be, read_u32_be, read_u64_be,
};

use std::io::{Cursor, Read};

bitflags::bitflags! {
    /// Table 4.1. Class access and property modifiers
    /// | Flag Name        | Value  | Interpretation                                                                     |
    /// | ---------------- | ------ | ---------------------------------------------------------------------------------- |
    /// | `ACC_PUBLIC`     | 0x0001 | Declared public; may be accessed from outside its package.                        |
    /// | `ACC_FINAL`      | 0x0010 | Declared final; no subclasses allowed.                                            |
    /// | `ACC_SUPER`      | 0x0020 | Treat superclass methods specially when invoked by the invokespecial instruction. |
    /// | `ACC_INTERFACE`  | 0x0200 | Is an interface, not a class.                                                     |
    /// | `ACC_ABSTRACT`   | 0x0400 | Declared abstract; must not be instantiated.                                      |
    /// | `ACC_SYNTHETIC`  | 0x1000 | Declared synthetic; not present in the source code.                               |
    /// | `ACC_ANNOTATION` | 0x2000 | Declared as an annotation type.                                                   |
    /// | `ACC_ENUM`       | 0x4000 | Declared as an enum type.                                                         |
    ///
    /// A class may be marked with the [`ClassAccessFlags::Synthetic`] flag to indicate that it was generated by a
    /// compiler and does not appear in source code.
    ///
    /// The [`ClassAccessFlags::Enum`] flag indicates that this class or its superclass is declared as an
    /// enumerated type.
    ///
    /// An interface is distinguished by its [`ClassAccessFlags::Interface`] flag being set. If its [`ClassAccessFlags::Interface`]
    /// flag is not set, this class file defines a class, not an interface.
    ///
    /// If the [`ClassAccessFlags::Interface`] flag of this class file is set, its [`ClassAccessFlags::Abstract`] flag must also be
    /// set (JLS §9.1.1.1). Such a class file must not have its [`ClassAccessFlags::Final`], [`ClassAccessFlags::Super`] or
    /// [`ClassAccessFlags::Enum`] flags set.
    ///
    /// An annotation type must have its [`ClassAccessFlags::Annotation`] flag set. If the [`ClassAccessFlags::Annotation`] flag is
    /// set, the [`ClassAccessFlags::Interface`] flag must be set as well. If the [`ClassAccessFlags::Interface`] flag of this
    /// class file is not set, it may have any of the other flags in Table 4.1 set, except the
    /// [`ClassAccessFlags::Annotation`] flag. However, such a class file cannot have both its [`ClassAccessFlags::Final`] and
    /// [`ClassAccessFlags::Abstract`] flags set (JLS §8.1.1.2).
    ///
    /// The [`ClassAccessFlags::Super`] flag indicates which of two alternative semantics is to be expressed by the
    /// invokespecial instruction (§invokespecial) if it appears in this class. Compilers to the
    /// instruction set of the Java Virtual Machine should set the [`ClassAccessFlags::Super`] flag.
    ///
    /// The [`ClassAccessFlags::Super`] flag exists for backward compatibility with code compiled by older compilers
    /// for the Java programming language. In Oracle’s JDK prior to release 1.0.2, the compiler
    /// generated [`ClassFile::access_flags`] in which the flag now representing [`ClassAccessFlags::Super`] had no
    /// assigned meaning, and Oracle's Java Virtual Machine implementation ignored the flag if it
    /// was set.
    ///
    /// All bits of the [`ClassFile::access_flags`] item not assigned in Table 4.1 are reserved for future
    /// use. They should be set to zero in generated class files and should be ignored by Java
    /// Virtual Machine implementations.
    // TODO: Add the above into each field
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    struct ClassAccessFlags: u16 {
        /// Declared public; may be accessed from outside its package.
        const Public = 0x0001;
        /// Declared final; no subclasses allowed.
        const Final = 0x0010;
        /// Treat superclass methods specially when invoked by the invokespecial instruction.
        const Super = 0x0020;
        /// Is an interface, not a class.
        const Interface = 0x0200;
        /// Declared abstract; must not be instantiated.
        const Abstract = 0x0400;
        /// Declared synthetic; not present in the source code.
        const Synthetic = 0x1000 ;
        /// Declared as an annotation type.
        const Annotation = 0x2000;
        /// Declared as an enum type.
        const Enum = 0x4000;
    }
}

bitflags::bitflags! {
    /// The value of the access_flags item is a mask of flags used to denote access permission to
    /// and properties of this method. The interpretation of each flag, when set, is as shown in
    /// Table 4.5.
    ///
    /// Table 4.5. Method access and property flags
    /// | Flag Name        | Value 	| Interpretation                                                 |
    /// | ---------------- | ------ | -------------------------------------------------------------- |
    /// | ACC_PUBLIC       | 0x0001 | Declared public; may be accessed from outside its package.     |
    /// | ACC_PRIVATE      | 0x0002 | Declared private; accessible only within the defining class.   |
    /// | ACC_PROTECTED    | 0x0004 | Declared protected; may be accessed within subclasses.         |
    /// | ACC_STATIC       | 0x0008 | Declared static.                                               |
    /// | ACC_FINAL        | 0x0010 | Declared final; must not be overridden (§5.4.5).               |
    /// | ACC_SYNCHRONIZED | 0x0020 | Declared synchronized; invocation is wrapped by a monitor use. |
    /// | ACC_BRIDGE       | 0x0040 | A bridge method, generated by the compiler.                    |
    /// | ACC_VARARGS      | 0x0080 | Declared with variable number of arguments.                    |
    /// | ACC_NATIVE       | 0x0100 | Declared native; implemented in a language other than Java.    |
    /// | ACC_ABSTRACT     | 0x0400 | Declared abstract; no implementation is provided.              |
    /// | ACC_STRICT       | 0x0800 | Declared strictfp; floating-point mode is FP-strict.           |
    /// | ACC_SYNTHETIC    | 0x1000 | Declared synthetic; not present in the source code.            |
    ///
    /// The [`MethodAccessFlags::VarArgs`] flag indicates that this method takes a variable number
    /// of arguments at the source code level. A method declared to take a variable number of
    /// arguments must be compiled with the [`MethodAccessFlags::VarArgs`] flag set to 1. All other
    /// methods must be compiled with the [`MethodAccessFlags::VarArgs`] flag set to 0.
    ///
    /// The [`MethodAccessFlags::Bridge`] flag is used to indicate a bridge method generated by a
    /// Java compiler.
    ///
    /// A method may be marked with the [`MethodAccessFlags::Synthetic`] flag to indicate that it
    /// was generated by a compiler and does not appear in source code, unless it is one of the
    /// methods named in §4.7.8.
    ///
    /// Methods of classes may set any of the flags in Table 4.5. However, a specific method of a
    /// class may have at most one of its [`MethodAccessFlags::Private`],
    /// [`MethodAccessFlags::Protected`] and [`MethodAccessFlags::Public`] flags set (JLS
    /// §8.4.3). If a specific method has its [`MethodAccessFlags::Abstract`] flag set, it must not have any of its
    /// [`MethodAccessFlags::Final`], [`MethodAccessFlags::Native`], [`MethodAccessFlags::Private`], [`MethodAccessFlags::Static`],
    /// [`MethodAccessFlags::Strict`] or [`MethodAccessFlags::Synchronized`] flags set (JLS
    /// §8.4.3.1, JLS §8.4.3.3, JLS §8.4.3.4).
    ///
    /// All interface methods must have their [`MethodAccessFlags::Abstract`] and [`MethodAccessFlags::Public`] flags
    /// set; they may have their [`MethodAccessFlags::VarArgs`], [`MethodAccessFlags::Bridge`] and
    /// [`MethodAccessFlags::Synthetic`] flags set and must not have any of the other flags in
    /// Table 4.5 set (JLS §9.4).
    ///
    /// A specific instance initialization method (§2.9) may have at most one of its
    /// [`MethodAccessFlags::Private`], [`MethodAccessFlags::Protected`], and
    /// [`MethodAccessFlags::Public`] flags set, and may also have its
    /// [`MethodAccessFlags::Strict`], [`MethodAccessFlags::VarArgs`] and
    /// [`MethodAccessFlags::Synthetic`] flags set, but must not have any of the other flags in
    /// Table 4.5 set.
    ///
    /// Class and interface initialization methods (§2.9) are called implicitly by the Java Virtual
    /// Machine. The value of their access_flags item is ignored except for the setting of the
    /// [`MethodAccessFlags::Strict`] flag.
    ///
    /// All bits of the access_flags item not assigned in Table 4.5 are reserved for future
    /// use. They should be set to zero in generated class files and should be ignored by Java
    /// Virtual Machine implementations.
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct MethodAccessFlags: u16 {
        /// Declared public; may be accessed from outside its package.
        const Public = 0x0001;
        /// Declared private; accessible only within the defining class.
        const Private = 0x0002;
        /// Declared protected; may be accessed within subclasses.
        const Protected = 0x0004;
        /// Declared static.
        const Static = 0x0008;
        /// Declared final; must not be overridden (§5.4.5).
        const Final = 0x0010;
        /// Declared synchronized; invocation is wrapped by a monitor use.
        const Synchronized = 0x0020;
        /// A bridge method, generated by the compiler.
        const Bridge = 0x0040;
        /// Declared with variable number of arguments.
        const VarArgs = 0x0080;
        /// Declared native; implemented in a language other than Java.
        const Native = 0x0100;
        /// Declared abstract; no implementation is provided.
        const Abstract = 0x0400;
        /// Declared strictfp; floating-point mode is FP-strict.
        const Strict = 0x0800;
        /// Declared synthetic; not present in the source code.
        const Synthetic = 0x1000;
    }
}

#[derive(Debug, Clone)]
pub enum ConstantPoolInfo {
    Utf8 {
        bytes: String,
    },

    /// The [`ConstantPoolInfo::Integer`] structure represents 4-byte
    /// numeric (int) constants.
    Integer {
        /// The bytes item of the [`ConstantPoolInfo::Integer`] structure represents the value of the int
        /// constant. The bytes of the value are stored in big-endian (high byte first) order.
        bytes: u32,
    },

    /// The [`ConstantPoolInfo::Float`] structure represents 4-byte
    /// numeric (float) constants.
    Float {
        /// The bytes item of the [`ConstantPoolInfo::Float`] structure represents the value of the float
        /// constant in IEEE 754 floating-point single format (§2.3.2). The bytes of the single
        /// format representation are stored in big-endian (high byte first) order.
        ///
        /// The value represented by the [`ConstantPoolInfo::Float`] structure is determined as
        /// follows. The bytes of the value are first converted into an int constant `bits`. Then:
        ///
        /// - If `bits` is `0x7f800000`, the float value will be positive infinity.
        /// - If `bits` is `0xff800000`, the float value will be negative infinity.
        /// - If `bits` is in the range `0x7f800001`-`0x7fffffff` or in the range
        ///   `0xff800001`-`0xffffffff`, the float value will be `NaN`.
        /// - In all other cases, let s, e, and m be three values that might be computed from bits:
        ///   ```java
        ///   int s = ((bits >> 31) == 0) ? 1 : -1;
        ///   int e = ((bits >> 23) & 0xff);
        ///   int m = (e == 0) ?
        ///           (bits & 0x7fffff) << 1 :
        ///           (bits & 0x7fffff) | 0x800000;
        ///   ```
        ///   Then the float value equals the result of the mathematical expression `s * m * 2**(e-150)`.
        ///
        ///   Note(chonk): I think this is equivalent to [`f32::from_bits`] when you take care of
        ///   th edge cases
        bytes: f32,
    },

    // TODO: Add docs
    Long {
        bytes: u64,
    },

    // TODO: Add docs
    Double {
        bytes: f64,
    },

    /// The [`ConstantPoolInfo::Class`] structure is used to represent a class or an interface.
    Class {
        /// The value of the [`ConstantPoolInfo::Class::name_index`] item must be a valid index into the [`ClassFile::constant_pool`]
        /// table. The [`ClassFile::constant_pool`] entry at that index must be a [`ConstantPoolInfo::Utf8`] (§4.4.7)
        /// structure representing a valid binary class or interface name encoded in internal form
        /// (§4.2.1).
        name_index: u16,
    },

    /// The [`ConstantPoolInfo::String`] structure is used to represent constant objects of the
    /// type `String`:
    String {
        /// The value of the [`ConstantPoolInfo::String::string_index`] item must be a valid index
        /// into the [`ClassFile::constant_pool`] table. The [`ClassFile::constant_pool`] entry at
        /// that index must be a [`ConstantPoolInfo::Utf8`] (§4.4.7) structure representing the
        /// sequence of Unicode code points to which the String object
        /// is to be initialized.
        string_index: u16,
    },

    /// Fields, methods, and interface methods are represented by similar structures.
    Fieldref {
        /// The value of the [`ConstantPoolInfo::Fieldref::class_index`] item must be a valid index
        /// into the [`ClassFile::constant_pool`] table. The [`ClassFile::constant_pool`] entry at
        /// that index must be a [`ConstantPoolInfo::Class`] (§4.4.1) structure representing a
        /// class or interface type that has the field or method as a member.
        ///
        /// The [`ConstantPoolInfo::Fieldref::class_index`] item of a
        /// [`ConstantPoolInfo::Fieldref`] structure may be either a class type or an interface
        /// type.
        class_index: u16,

        /// The value of the [`ConstantPoolInfo::Fieldref::name_and_type_index`] item must be a
        /// valid index into the [`ClassFile::constant_pool`] table. The
        /// [`ClassFile::constant_pool`] entry at that index must be a [`ConstantPoolInfo::NameAndType`]
        /// (§4.4.6) structure. This [`ClassFile::constant_pool`] entry indicates the name and
        /// descriptor of the field or method.
        ///
        /// In a [`ConstantPoolInfo::Fieldref`], the indicated descriptor must be a field
        /// descriptor (§4.3.2). Otherwise, the indicated descriptor must be a method descriptor
        /// (§4.3.3).
        name_and_type_index: u16,
    },

    /// Fields, methods, and interface methods are represented by similar structures.
    Methodref {
        /// The value of the [`ConstantPoolInfo::Fieldref::class_index`] item must be a valid index
        /// into the [`ClassFile::constant_pool`] table. The [`ClassFile::constant_pool`] entry at
        /// that index must be a [`ConstantPoolInfo::Class`] (§4.4.1) structure representing a
        /// class or interface type that has the field or method as a member.
        ///
        /// The [`ConstantPoolInfo::Fieldref::class_index`] item of a
        /// [`ConstantPoolInfo::Fieldref`] structure may be either a class type or an interface
        /// type.
        ///
        /// The [`ConstantPoolInfo::Methodref::class_index`] item of a
        /// [`ConstantPoolInfo::Methodref`] structure must be a class type, not an interface type.
        class_index: u16,

        /// The value of the [`ConstantPoolInfo::Fieldref::name_and_type_index`] item must be a
        /// valid index into the [`ClassFile::constant_pool`] table. The
        /// [`ClassFile::constant_pool`] entry at that index must be a [`ConstantPoolInfo::NameAndType`]
        /// (§4.4.6) structure. This [`ClassFile::constant_pool`] entry indicates the name and
        /// descriptor of the field or method.
        ///
        /// If the name of the method of a [`ConstantPoolInfo::Methodref`]structure begins with a
        /// '<' ('\u003c'), then the name must be the special name `<init>`, representing an instance
        /// initialization method (§2.9). The return type of such a method must be void.
        name_and_type_index: u16,
    },
    InterfaceMethodref,

    /// The [`ConstantPoolInfo::NameAndType`] structure is used to represent a field or method,
    /// without indicating which class or interface type it belongs to:
    NameAndType {
        /// The value of the [`ConstantPoolInfo::NameAndType::name_index`] item must be a valid
        /// index into the [`ClassFile::constant_pool`] table. The [`ClassFile::constant_pool`]
        /// entry at that index must be a [`ConstantPoolInfo::Utf8`] (§4.4.7) structure
        /// representing either the special method name `<init>` (§2.9) or a valid unqualified name
        /// (§4.2.2) denoting a field or method.
        name_index: u16,

        /// The value of the [`ConstantPoolInfo::NameAndType::descriptor_index`] item must be a
        /// valid index into the [`ClassFile::constant_pool`] table. The
        /// [`ClassFile::constant_pool`] entry at that index must be a [`ConstantPoolInfo::Utf8`]
        /// (§4.4.7) structure representing a valid field descriptor (§4.3.2) or method descriptor
        /// (§4.3.3).
        descriptor_index: u16,
    },
    MethodHandle,
    MethodType,
    InvokeDynamic,
}

impl ConstantPoolInfo {
    fn parse(buf: &mut Cursor<&[u8]>) -> Self {
        let tag = read_u8_be(buf);
        match tag {
            // Utf8
            1 => {
                let length = read_u16_be(buf).into();
                let mut bytes = vec![0; length];
                buf.read_exact(&mut bytes).expect("it's a cursor");
                let str =
                    String::from_utf8(bytes).expect("TODO: parse whatever the fuck strings are");

                Self::Utf8 { bytes: str }
            }
            // Integer
            3 => Self::Integer {
                bytes: read_u32_be(buf),
            },
            // Float
            4 => Self::Float {
                bytes: read_f32_be(buf),
            },
            // Long
            5 => {
                todo!("indexes for long count as 2 indexes (WHAT?) so we need to shift accordingly")
                // Self::Long {
                // bytes: read_u64_be(buf),
                // }
            }
            // Double
            6 => {
                todo!(
                    "indexes for double count as 2 indexes (WHAT?) so we need to shift accordingly"
                )
                // Self::Double {
                // bytes: read_f64_be(buf),
                // }
            }
            // Class
            7 => Self::Class {
                name_index: read_u16_be(buf),
            },
            // String
            8 => Self::String {
                string_index: read_u16_be(buf),
            },
            // Fieldref
            9 => {
                let class_index = read_u16_be(buf) - 1;
                let name_and_type_index = read_u16_be(buf) - 1;
                Self::Fieldref {
                    class_index,
                    name_and_type_index,
                }
            }
            // Methodref
            10 => {
                let class_index = read_u16_be(buf) - 1;
                let name_and_type_index = read_u16_be(buf) - 1;
                Self::Methodref {
                    class_index,
                    name_and_type_index,
                }
            }
            // InterfaceMethodref
            11 => todo!(),
            // NameAndType
            12 => {
                let name_index = read_u16_be(buf) - 1;
                let descriptor_index = read_u16_be(buf) - 1;
                Self::NameAndType {
                    name_index,
                    descriptor_index,
                }
            }
            // MethodHandle
            15 => todo!(),
            // MethodType
            16 => todo!(),
            // InvokeDynamic
            18 => todo!(),
            _ => panic!("invalid tag {tag}"),
        }
    }
}

#[derive(Debug, Clone)]
struct FieldInfo {}

impl FieldInfo {
    fn parse(_reader: &mut impl Read) -> Self {
        todo!()
    }
}

/// A field descriptor represents the type of a class, instance, or local variable. It is a series of characters generated by the grammar:
///
///
/// ```
/// FieldDescriptor:
///     FieldType
///
/// FieldType:
///     BaseType
///     ObjectType
///     ArrayType
///
/// BaseType:
///     B
///     C
///     D
///     F
///     I
///     J
///     S
///     Z
///
/// ObjectType:
///     L ClassName ;
///
/// ArrayType:
///     [ ComponentType
///
/// ComponentType:
///     FieldType
/// ```
///
/// The characters of BaseType, the L and ; of ObjectType, and the [ of ArrayType are all ASCII
/// characters.
///
/// The ClassName represents a binary class or interface name encoded in internal form.
///
/// The interpretation of field descriptors as types is as shown in Table 4.2.
///
/// A field descriptor representing an array type is valid only if it represents a type with 255 or fewer dimensions.
///
/// Table 4.2. Interpretation of FieldType characters
/// | BaseType Character | Type      | Interpretation                                                                    |
/// | ------------------ | --------- | --------------------------------------------------------------------------------- |
/// | B                  | byte      | signed byte                                                                       |
/// | C                  | char      | Unicode character code point in the Basic Multilingual Plane, encoded with UTF-16 |
/// | D                  | double    | double-precision floating-point value                                             |
/// | F                  | float     | single-precision floating-point value                                             |
/// | I                  | int       | integer                                                                           |
/// | J                  | long      | long integer                                                                      |
/// | L ClassName ;      | reference | an instance of class ClassName                                                    |
/// | S                  | short     | signed short                                                                      |
/// | Z                  | boolean   | true or false                                                                     |
/// | [                  | reference | one array dimension                                                               |
///
/// The field descriptor of an instance variable of type int is simply I.
///
/// The field descriptor of an instance variable of type Object is Ljava/lang/Object;. Note that
/// the internal form of the binary name for class Object is used.
///
/// The field descriptor of an instance variable that is a multidimensional double array, double
/// d[][][], is [[[D.
#[derive(Debug, Clone)]
pub enum FieldDescriptor {
    Byte,
    Char,
    Double,
    Float,
    Int,
    Long,
    Class {
        class_name: String,
    },
    Short,
    Boolean,
    Array {
        ty: Box<FieldDescriptor>,
    },

    /// This is only valid for return types of methods, but it still behaves like one of these, so
    /// we put it here.
    Void,
}

impl FieldDescriptor {
    fn parse_one(s: &str) -> (Self, &str) {
        match s.chars().next().expect("can't parse an empty descriptor") {
            'B' => (Self::Byte, &s[1..]),
            'C' => (Self::Char, &s[1..]),
            'D' => (Self::Double, &s[1..]),
            'F' => (Self::Float, &s[1..]),
            'J' => (Self::Long, &s[1..]),
            'I' => (Self::Int, &s[1..]),
            'S' => (Self::Short, &s[1..]),
            'Z' => (Self::Boolean, &s[1..]),
            'V' => (Self::Void, &s[1..]),
            'L' => {
                let rest = &s[1..];
                let (class_name, rest) = rest.split_once(';').expect("types should end with ';'");

                (
                    Self::Class {
                        class_name: class_name.to_owned(),
                    },
                    rest,
                )
            }
            '[' => {
                let (desc, rest) = Self::parse_one(&s[1..]);
                (Self::Array { ty: Box::new(desc) }, rest)
            }
            c => panic!("unexpected descriptor type {c}"),
        }
    }
}

/// A method descriptor represents the parameters that a method takes and the value that it returns.
///
/// ```
/// MethodDescriptor:
///     (ParameterDescriptor*) ReturnDescriptor
/// ```
/// A parameter descriptor represents a parameter passed to a method:
///
/// ```
/// ParameterDescriptor:
///     FieldType
/// ```
///
/// A return descriptor represents the type of the value returned from a method. It is a series of characters generated by the grammar:
///
/// ```
/// ReturnDescriptor:
///     FieldType
///     VoidDescriptor
///
/// VoidDescriptor:
///     V
/// ```
///
/// The character V indicates that the method returns no value (its return type is void).
///
/// A method descriptor is valid only if it represents method parameters with a total length of 255
/// or less, where that length includes the contribution for this in the case of instance or
/// interface method invocations. The total length is calculated by summing the contributions of
/// the individual parameters, where a parameter of type long or double contributes two units to
/// the length and a parameter of any other type contributes one unit.
///
/// The method descriptor for the method:
///
/// ```
/// Object m(int i, double d, Thread t) {..}
/// ```
///
/// is `(IDLjava/lang/Thread;)Ljava/lang/Object;`. Note that the internal forms of the binary names
/// of Thread and Object are used.
///
/// The method descriptor for `m` is the same whether `m` is a class method or an instance
/// method. Although an instance method is passed this, a reference to the current class instance,
/// in addition to its intended parameters, that fact is not reflected in the method
/// descriptor. The reference to this is passed implicitly by the method invocation instructions of
/// the Java Virtual Machine that invoke instance methods (§2.6.1). A reference to this is not
/// passed to a class method.
#[derive(Debug, Clone)]
pub struct MethodDescriptor {
    /// The parameters to the method. Notably doesn't include the `this` parameter, even if the
    /// method is an instance method.
    pub parameters: Vec<FieldDescriptor>,

    /// The return type of the method. None indicates `void`.
    pub return_ty: FieldDescriptor,
}

impl MethodDescriptor {
    pub fn parse(desc: &str) -> Self {
        let (_, mut rest) = desc.split_once('(').expect("descriptor has a leading '('");

        let mut parameters = vec![];
        println!("parsing method parameters");
        loop {
            let first = rest
                .chars()
                .next()
                .expect("no ')' to finish method parameters");
            if first == ')' {
                break;
            }

            let (descriptor, rest1) = FieldDescriptor::parse_one(rest);
            rest = rest1;
            println!("descriptor: {descriptor:?}");
            parameters.push(descriptor);
        }
        // skip ')'
        rest = &rest[1..];
        println!("finished parsing method parameters");

        let (return_ty, _) = FieldDescriptor::parse_one(rest);

        Self {
            parameters,
            return_ty,
        }
    }
}

#[derive(Debug, Clone)]
pub struct MethodInfo {
    /// The value of the [`MethodInfo::access_flags`] item is a mask of flags used to denote access
    /// permission to and properties of this method. The interpretation of each flag, when set, is
    /// as shown in [`MethodAccessFlags`].
    pub access_flags: MethodAccessFlags,

    /// The value of the [`MethodInfo::name_index`] item must be a valid index into the
    /// [`ClassFile::constant_pool`] table. The [`ClassFile::constant_pool`] entry at that index
    /// must be a [`ConstantPoolInfo::Utf8`] (§4.4.7) structure representing either one of the
    /// special method names (§2.9) `<init>` or `<clinit>`, or a valid unqualified name (§4.2.2)
    /// denoting a method.
    pub name_index: u16,

    /// The value of the [`MethodInfo::descriptor_index`] item must be a valid index into the
    /// [`ClassFile::constant_pool`] table. The [`ClassFile::constant_pool`] entry at that index
    /// must be a [`ConstantPoolInfo::Utf8`] (§4.4.7) structure representing a valid method
    /// descriptor (§4.3.3).
    ///
    /// A future edition of this specification may require that the last parameter descriptor of
    /// the method descriptor is an array type if the [`MethodAccessFlags::VarArgs`] flag is set in
    /// the [`MethodInfo::access_flags`] item.
    pub descriptor_index: u16,

    /// Each value of the attributes table must be an attribute structure ([`AttributeInfo`]). A
    /// method can have any number of optional attributes associated with it.
    ///
    /// The attributes defined by this specification as appearing in the attributes table of a
    /// [`MethodInfo`] structure are the `Code`, `Exceptions`, `Synthetic`, `Signature`,
    /// `Deprecated`, `RuntimeVisibleAnnotations`, `RuntimeInvisibleAnnotations`,
    /// `RuntimeVisibleParameterAnnotations`, `RuntimeInvisibleParameterAnnotations`, and
    /// `AnnotationDefault` attributes.
    ///
    /// A Java Virtual Machine implementation must recognize and correctly read `Code` and
    /// `Exceptions` attributes found in the attributes table of a [`MethodInfo`] structure. If a
    /// Java Virtual Machine implementation recognizes class files whose version number is `49.0`
    /// or above, it must recognize and correctly read `Signature`, `RuntimeVisibleAnnotations`,
    /// `RuntimeInvisibleAnnotations`, `RuntimeVisibleParameterAnnotations`,
    /// `RuntimeInvisibleParameterAnnotations` and `AnnotationDefault` attributes found in the
    /// attributes table of a [`MethodInfo`] structure of a class file whose version number is
    /// `49.0` or above.
    ///
    /// A Java Virtual Machine implementation is required to silently ignore any or all attributes
    /// in the attributes table of a [`MethodInfo`] structure that it does not recognize. Attributes
    /// not defined in this specification are not allowed to affect the semantics of the class
    /// file, but only to provide additional descriptive information.
    pub attributes: Vec<AttributeInfo>,
}

impl MethodInfo {
    fn parse(reader: &mut impl Read, constant_pool: &[ConstantPoolInfo]) -> Self {
        let access_flags = MethodAccessFlags::from_bits(read_u16_be(reader))
            .expect("access flags should be valid");

        let name_index = read_u16_be(reader) - 1;
        println!("Method name index: {name_index}");

        let descriptor_index = read_u16_be(reader) - 1;
        println!("Descriptor name index: {descriptor_index}");

        let attribute_count = read_u16_be(reader);
        println!("Parsing {attribute_count} method attributes");
        let attributes = (0..attribute_count)
            .filter_map(|i| {
                let attribute = AttributeInfo::parse(reader, constant_pool);
                if let Some(attribute) = &attribute {
                    println!("{i}: Found attribute {attribute:?}");
                }
                attribute
            })
            .collect();

        Self {
            access_flags,
            name_index,
            descriptor_index,
            attributes,
        }
    }
}

#[derive(Clone, Debug)]
struct ExceptionCodeEntry {
    start_pc: u16,
    end_pc: u16,
    handler_pc: u16,
    catch_type: u16,
}

/// Attributes are used in the [`ClassFile`], [`FieldInfo`], [`MethodInfo`], and [`AttributeInfo::Code`] structures of
/// the class file format.
///
/// Certain attributes are predefined as part of the class file specification. They are listed in
/// Table 4.6, accompanied by the version of the Java SE platform and the version of the class file
/// format in which each first appeared. Within the context of their use in this specification,
/// that is, in the attributes tables of the class file structures in which they appear, the names
/// of these predefined attributes are reserved. Of the predefined attributes:
///
/// The ConstantValue, Code and Exceptions attributes must be recognized and correctly read by a
/// class file reader for correct interpretation of the class file by a Java Virtual Machine
/// implementation.
///
/// The InnerClasses, EnclosingMethod and Synthetic attributes must be recognized and correctly
/// read by a class file reader in order to properly implement the Java SE platform class libraries
/// (§2.12).
///
/// The RuntimeVisibleAnnotations, RuntimeInvisibleAnnotations, RuntimeVisibleParameterAnnotations,
/// RuntimeInvisibleParameterAnnotations and AnnotationDefault attributes must be recognized and
/// correctly read by a class file reader in order to properly implement the Java SE platform class
/// libraries (§2.12), if the class file's version number is 49.0 or above and the Java Virtual
/// Machine implementation recognizes class files whose version number is 49.0 or above.
///
/// The Signature attribute must be recognized and correctly read by a class file reader if the
/// class file's version number is 49.0 or above and the Java Virtual Machine implementation
/// recognizes class files whose version number is 49.0 or above.
///
/// The StackMapTable attribute must be recognized and correctly read by a class file reader if the
/// class file's version number is 50.0 or above and the Java Virtual Machine implementation
/// recognizes class files whose version number is 50.0 or above.
///
/// The BootstrapMethods attribute must be recognized and correctly read by a class file reader if
/// the class file's version number is 51.0 or above and the Java Virtual Machine implementation
/// recognizes class files whose version number is 51.0 or above.
///
/// Table 4.6:  Predefined class file attributes
/// | Attribute                              | Java SE   | Class File Version   |
/// | -------------------------------------- | -------   | -------------------- |
/// | `ConstantValue`                        | `1.0.2`   | `45.3`               |
/// | `Code`                                 | `1.0.2`   | `45.3`               |
/// | `StackMapTable`                        | `6`       | `50.0`               |
/// | `Exceptions`                           | `1.0.2`   | `45.3`               |
/// | `InnerClasses`                         | `1.1`     | `45.3`               |
/// | `EnclosingMethod`                      | `5.0`     | `49.0`               |
/// | `Synthetic`                            | `1.1`     | `45.3`               |
/// | `Signature`                            | `5.0`     | `49.0`               |
/// | `SourceFile`                           | `1.0.2`   | `45.3`               |
/// | `SourceDebugExtension`                 | `5.0`     | `49.0`               |
/// | `LineNumberTable`                      | `1.0.2`   | `45.3`               |
/// | `LocalVariableTable`                   | `1.0.2`   | `45.3`               |
/// | `LocalVariableTypeTable`               | `5.0`     | `49.0`               |
/// | `Deprecated`                           | `1.1`     | `45.3`               |
/// | `RuntimeVisibleAnnotations`            | `5.0`     | `49.0`               |
/// | `RuntimeInvisibleAnnotations`          | `5.0`     | `49.0`               |
/// | `RuntimeVisibleParameterAnnotations`   | `5.0`     | `49.0`               |
/// | `RuntimeInvisibleParameterAnnotations` | `5.0`     | `49.0`               |
/// | `AnnotationDefault`                    | `5.0`     | `49.0`               |
/// | `BootstrapMethods`                     | `7`       | `51.0`               |
#[derive(Debug, Clone)]
pub enum AttributeInfo {
    ConstantValue {
        constantvalue_index: u16,
    },
    Code {
        max_stack: u16,
        max_locals: u16,
        code: Vec<u8>,
        exception_table: Vec<ExceptionCodeEntry>,
        attributes: Vec<AttributeInfo>,
    },
    StackMapTable,
    Exceptions,
    InnerClasses,
    EnclosingMethod,
    Synthetic,
    Signature,
    SourceFile {
        sourcefile_index: u16,
    },
    SourceDebugExtension,
    LineNumberTable,
    LocalVariableTable,
    LocalVariableTypeTable,
    Deprecated,
    RuntimeVisibleAnnotations,
    RuntimeInvisibleAnnotations,
    RuntimeVisibleParameterAnnotations,
    RuntimeInvisibleParameterAnnotations,
    AnnotationDefault,
    BootstrapMethods,
}

impl AttributeInfo {
    fn parse(reader: &mut impl Read, constant_pool: &[ConstantPoolInfo]) -> Option<Self> {
        let attribute_name_index = read_u16_be(reader) - 1;
        let attribute_name_index: usize = attribute_name_index.into();

        let attribute_name = &constant_pool[attribute_name_index];

        let ConstantPoolInfo::Utf8 {
            bytes: attribute_name,
        } = attribute_name
        else {
            panic!(
                "attribute_name_index should point to an attribute_name, it pointed to {attribute_name:?}"
            );
        };

        let attribute_length = read_u32_be(reader);
        match attribute_name.as_str() {
            "ConstantValue" => Some(Self::ConstantValue {
                constantvalue_index: read_u16_be(reader),
            }),
            "Code" => {
                let max_stack = read_u16_be(reader);
                let max_locals = read_u16_be(reader);

                let code_length = read_u32_be(reader);
                let code = (0..code_length).map(|_| read_u8_be(reader)).collect();

                let exception_table_length = read_u16_be(reader);
                let exception_table = (0..exception_table_length)
                    .map(|_| {
                        let start_pc = read_u16_be(reader);
                        let end_pc = read_u16_be(reader);
                        let handler_pc = read_u16_be(reader);
                        let catch_type = read_u16_be(reader);

                        ExceptionCodeEntry {
                            start_pc,
                            end_pc,
                            handler_pc,
                            catch_type,
                        }
                    })
                    .collect();

                let attribute_count = read_u16_be(reader);
                let attributes = (0..attribute_count)
                    .filter_map(|_| Self::parse(reader, constant_pool))
                    .collect();

                Some(Self::Code {
                    max_stack,
                    max_locals,
                    code,
                    exception_table,
                    attributes,
                })
            }
            "SourceFile" => Some(Self::SourceFile {
                sourcefile_index: read_u16_be(reader) - 1,
            }),
            _ => {
                println!("Ignoring attribute name {attribute_name}");

                read_exact_bytes(
                    reader,
                    attribute_length
                        .try_into()
                        .expect("attribute_length was more than usize"),
                );
                None
            }
        }
    }
}

/// The contents of a `.class` file.
///
/// The docs are mostly from
/// <https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html#jvms-4.1/>
#[derive(Debug, Clone)]
pub struct ClassFile {
    /// The magic item supplies the magic number identifying the class file format; it has the
    /// value 0xCAFEBABE.
    pub magic: u32,

    /// The values of the [`ClassFile::minor_version`] and [`ClassFile::major_version`] items are the minor and major version
    /// numbers of this class file. Together, a major and a minor version number determine the
    /// version of the class file format. If a class file has major version number M and minor
    /// version number m, we denote the version of its class file format as M.m. Thus, class file
    /// format versions may be ordered lexicographically, for example, 1.5 < 2.0 < 2.1.
    pub minor_version: u16,

    /// Refer to [`ClassFile::minor_version`] docs.
    pub major_version: u16,

    /// The value of the `constant_pool_count` item is equal to the number of entries in the
    /// [`ClassFile::constant_pool`] table plus one. A [`ClassFile::constant_pool`] index is considered valid if it is greater
    /// than zero and less than `constant_pool_count`, with the exception for constants of type long
    /// and double noted in §4.4.5.
    /// Note(chonk): The constant pool indexes are 1-based??? What???
    /// Note(chonk): We offset these by one when reading them, to make them sane.
    ///
    /// The length is u16.
    ///
    /// The [`ClassFile::constant_pool`] is a table of structures (§4.4) representing various string constants,
    /// class and interface names, field names, and other constants that are referred to within the
    /// [`ClassFile`] structure and its substructures. The format of each [`ClassFile::constant_pool`] table entry is
    /// indicated by its first "tag" byte.
    /// The [`ClassFile::constant_pool`] table is indexed from 1 to `constant_pool_count-1`.
    pub constant_pool: Vec<ConstantPoolInfo>,

    /// The value of the [`ClassFile::access_flags`] item is a mask of flags used to denote access permissions to
    /// and properties of this class or interface. The interpretation of each flag, when set, is as
    /// shown in Table 4.1.
    pub access_flags: ClassAccessFlags,

    /// The value of the `this_class` item must be a valid index into the [`ClassFile::constant_pool`] table. The
    /// [`ClassFile::constant_pool`] entry at that index must be a `CONSTANT_Class_info` structure
    /// representing the class or interface defined by this class file.
    pub this_class: u16,

    /// For a class, the value of the [`ClassFile::super_class`] item either must be zero or must be a valid index
    /// into the [`ClassFile::constant_pool`] table. If the value of the [`ClassFile::super_class`] item is nonzero, the
    /// [`ClassFile::constant_pool`] entry at that index must be a `CONSTANT_Class_info` structure
    /// representing the direct superclass of the class defined by this class file. Neither the
    /// direct superclass nor any of its superclasses may have the [`ClassAccessFlags::Final`] flag set in the
    /// [`ClassFile::access_flags`] item of its [`ClassFile`] structure.
    ///
    /// If the value of the [`ClassFile::super_class`] item is zero, then this class file must represent the class
    /// Object, the only class or interface without a direct superclass.
    ///
    /// For an interface, the value of the [`ClassFile::super_class`] item must always be a valid index into the
    /// [`ClassFile::constant_pool`] table. The [`ClassFile::constant_pool`] entry at that index
    /// must be a `CONSTANT_Class_info` structure representing the class Object.
    pub super_class: u16,

    /// The value of the `interfaces_count` item gives the number of direct superinterfaces of this
    /// class or interface type.
    ///
    /// This count is a u16.
    ///
    /// Each value in the interfaces array must be a valid index into the [`ClassFile::constant_pool`] table. The
    /// [`ClassFile::constant_pool`] entry at each value of interfaces\[i\], where 0 ≤ i < `interfaces_count`, must be
    /// a `CONSTANT_Class_info` structure (§4.4.1) representing an interface that is a direct
    /// superinterface of this class or interface type, in the left-to-right order given in the
    /// source for the type.
    pub interfaces: Vec<u16>,

    /// The value of the `fields_count` item gives the number of [`FieldInfo`] structures in the
    /// [`ClassFile::fields`] table. The [`FieldInfo`] structures (§4.5) represent all fields, both
    /// class variables and instance variables, declared by this class or interface type.
    ///
    /// Each value in the fields table must be a [`FieldInfo`] (§4.5) structure giving a complete
    /// description of a field in this class or interface. The fields table includes only those
    /// fields that are declared by this class or interface. It does not include items representing
    /// fields that are inherited from superclasses or superinterfaces.
    pub fields: Vec<FieldInfo>,

    /// The value of the `methods_count` item gives the number of [`MethodInfo`] structures in the
    /// methods table.
    ///
    /// Each value in the methods table must be a [`MethodInfo`] (§4.6) structure giving a complete
    /// description of a method in this class or interface. If neither of the
    /// [`MethodAccessFlags::Native`] and [`MethodAccessFlags::Abstract`] flags are set in the
    /// [`MethodInfo::access_flags`] item of a [`MethodInfo`] structure, the Java Virtual Machine
    /// instructions implementing the method are also supplied.
    ///
    /// The [`MethodInfo`] structures represent all methods declared by this class or interface
    /// type, including instance methods, class methods, instance initialization methods (§2.9),
    /// and any class or interface initialization method (§2.9). The methods table does not include
    /// items representing methods that are inherited from superclasses or superinterfaces.
    pub methods: Vec<MethodInfo>,

    pub attributes: Vec<AttributeInfo>,
}

pub fn parse_class_file(class_file: &[u8]) -> ClassFile {
    let reader = &mut Cursor::new(class_file);
    let magic = read_u32_be(reader);
    println!("Magic: {magic:x}");

    let minor_version = read_u16_be(reader);
    let major_version = read_u16_be(reader);
    println!("Version {major_version}.{minor_version}");

    // Refer to [`ClassFile::constant_pool`].
    // Note(chonk): Why did they do this?
    let constant_pool_count = read_u16_be(reader) - 1;
    println!("There are {constant_pool_count} constants");
    let constant_pool: Vec<ConstantPoolInfo> = (0..constant_pool_count)
        .map(|i| {
            let info = ConstantPoolInfo::parse(reader);
            println!("{i}: Found constant {info:?}");
            info
        })
        .collect();

    println!();

    let access_flags =
        ClassAccessFlags::from_bits(read_u16_be(reader)).expect("access flags should be valid");
    println!("Access flags: {access_flags:?}");

    let this_class = read_u16_be(reader);
    println!("This class: {this_class}");

    let super_class = read_u16_be(reader);
    println!("Super class: {super_class}");
    println!();

    let interfaces_count = read_u16_be(reader);
    let interfaces = (0..interfaces_count).map(|_| read_u16_be(reader)).collect();
    println!("Interfaces: {interfaces:?}");
    println!();

    let field_count = read_u16_be(reader);
    println!("Parsing {field_count} fields");
    let fields = (0..field_count)
        .map(|i| {
            let info = FieldInfo::parse(reader);
            println!("{i}: Found field {info:?}");
            info
        })
        .collect();
    println!();

    let method_count = read_u16_be(reader);
    println!("Parsing {method_count} methods");
    let methods = (0..method_count)
        .map(|i| {
            let info = MethodInfo::parse(reader, &constant_pool);
            println!("{i}: Found method {info:?}");
            info
        })
        .collect();

    let attribute_count = read_u16_be(reader);
    println!("Parsing {attribute_count} attributes");
    let attributes = (0..attribute_count)
        .filter_map(|i| {
            let info = AttributeInfo::parse(reader, &constant_pool);
            println!("{i}: Found attribute {info:?}");
            info
        })
        .collect();

    ClassFile {
        magic,
        minor_version,
        major_version,
        constant_pool,
        access_flags,
        this_class,
        super_class,
        interfaces,
        fields,
        methods,
        attributes,
    }
}
