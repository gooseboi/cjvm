// Useful links:
// Jar file spec: https://docs.oracle.com/en/java/javase/20/docs/specs/jar/jar.html
// Class file spec: https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html

use crate::utils::{read_f32_be, read_f64_be, read_u8_be, read_u16_be, read_u32_be, read_u64_be};

use std::io::{Cursor, Read};

bitflags::bitflags! {
    /// Table 4.1. Class access and property modifiers
    /// | Flag Name        | Value  | Interpretation                                                                     |
    /// | ---------------- | ------ | ---------------------------------------------------------------------------------- |
    /// | `ACC_PUBLIC`     | 0x0001 | Declared public; may be accessed from outside its package.                        |
    /// | `ACC_FINAL`      | 0x0010 | Declared final; no subclasses allowed.                                            |
    /// | `ACC_SUPER`      | 0x0020 | Treat superclass methods specially when invoked by the invokespecial instruction. |
    /// | `ACC_INTERFACE`  | 0x0200 | Is an interface, not a class.                                                     |
    /// | `ACC_ABSTRACT`   | 0x0400 | Declared abstract; must not be instantiated.                                      |
    /// | `ACC_SYNTHETIC`  | 0x1000 | Declared synthetic; not present in the source code.                               |
    /// | `ACC_ANNOTATION` | 0x2000 | Declared as an annotation type.                                                   |
    /// | `ACC_ENUM`       | 0x4000 | Declared as an enum type.                                                         |
    ///
    /// A class may be marked with the [`ClassAccessFlags::Synthetic`] flag to indicate that it was generated by a
    /// compiler and does not appear in source code.
    ///
    /// The [`ClassAccessFlags::Enum`] flag indicates that this class or its superclass is declared as an
    /// enumerated type.
    ///
    /// An interface is distinguished by its [`ClassAccessFlags::Interface`] flag being set. If its [`ClassAccessFlags::Interface`]
    /// flag is not set, this class file defines a class, not an interface.
    ///
    /// If the [`ClassAccessFlags::Interface`] flag of this class file is set, its [`ClassAccessFlags::Abstract`] flag must also be
    /// set (JLS §9.1.1.1). Such a class file must not have its [`ClassAccessFlags::Final`], [`ClassAccessFlags::Super`] or
    /// [`ClassAccessFlags::Enum`] flags set.
    ///
    /// An annotation type must have its [`ClassAccessFlags::Annotation`] flag set. If the [`ClassAccessFlags::Annotation`] flag is
    /// set, the [`ClassAccessFlags::Interface`] flag must be set as well. If the [`ClassAccessFlags::Interface`] flag of this
    /// class file is not set, it may have any of the other flags in Table 4.1 set, except the
    /// [`ClassAccessFlags::Annotation`] flag. However, such a class file cannot have both its [`ClassAccessFlags::Final`] and
    /// [`ClassAccessFlags::Abstract`] flags set (JLS §8.1.1.2).
    ///
    /// The [`ClassAccessFlags::Super`] flag indicates which of two alternative semantics is to be expressed by the
    /// invokespecial instruction (§invokespecial) if it appears in this class. Compilers to the
    /// instruction set of the Java Virtual Machine should set the [`ClassAccessFlags::Super`] flag.
    ///
    /// The [`ClassAccessFlags::Super`] flag exists for backward compatibility with code compiled by older compilers
    /// for the Java programming language. In Oracle’s JDK prior to release 1.0.2, the compiler
    /// generated [`ClassFile::access_flags`] in which the flag now representing [`ClassAccessFlags::Super`] had no
    /// assigned meaning, and Oracle's Java Virtual Machine implementation ignored the flag if it
    /// was set.
    ///
    /// All bits of the [`ClassFile::access_flags`] item not assigned in Table 4.1 are reserved for future
    /// use. They should be set to zero in generated class files and should be ignored by Java
    /// Virtual Machine implementations.
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    struct ClassAccessFlags: u16 {
        ///Declared public; may be accessed from outside its package.
        const Public = 0x0001;
        /// Declared final; no subclasses allowed.
        const Final = 0x0010;
        ///Treat superclass methods specially when invoked by the invokespecial instruction.
        const Super = 0x0020;
        /// Is an interface, not a class.
        const Interface = 0x0200;
        /// Declared abstract; must not be instantiated.
        const Abstract = 0x0400;
        ///  Declared synthetic; not present in the source code.
        const Synthetic = 0x1000 ;
        /// Declared as an annotation type.
        const Annotation = 0x2000;
        /// Declared as an enum type.
        const Enum = 0x4000;
    }
}

bitflags::bitflags! {
    /// The value of the access_flags item is a mask of flags used to denote access permission to
    /// and properties of this method. The interpretation of each flag, when set, is as shown in
    /// Table 4.5.
    ///
    /// Table 4.5. Method access and property flags
    /// | Flag Name        | Value 	| Interpretation                                                 |
    /// | ---------------- | ------ | -------------------------------------------------------------- |
    /// | ACC_PUBLIC       | 0x0001 | Declared public; may be accessed from outside its package.     |
    /// | ACC_PRIVATE      | 0x0002 | Declared private; accessible only within the defining class.   |
    /// | ACC_PROTECTED    | 0x0004 | Declared protected; may be accessed within subclasses.         |
    /// | ACC_STATIC       | 0x0008 | Declared static.                                               |
    /// | ACC_FINAL        | 0x0010 | Declared final; must not be overridden (§5.4.5).               |
    /// | ACC_SYNCHRONIZED | 0x0020 | Declared synchronized; invocation is wrapped by a monitor use. |
    /// | ACC_BRIDGE       | 0x0040 | A bridge method, generated by the compiler.                    |
    /// | ACC_VARARGS      | 0x0080 | Declared with variable number of arguments.                    |
    /// | ACC_NATIVE       | 0x0100 | Declared native; implemented in a language other than Java.    |
    /// | ACC_ABSTRACT     | 0x0400 | Declared abstract; no implementation is provided.              |
    /// | ACC_STRICT       | 0x0800 | Declared strictfp; floating-point mode is FP-strict.           |
    /// | ACC_SYNTHETIC    | 0x1000 | Declared synthetic; not present in the source code.            |
    ///
    /// The [`MethodAccessFlags::VarArgs`] flag indicates that this method takes a variable number
    /// of arguments at the source code level. A method declared to take a variable number of
    /// arguments must be compiled with the [`MethodAccessFlags::VarArgs`] flag set to 1. All other
    /// methods must be compiled with the [`MethodAccessFlags::VarArgs`] flag set to 0.
    ///
    /// The [`MethodAccessFlags::Bridge`] flag is used to indicate a bridge method generated by a
    /// Java compiler.
    ///
    /// A method may be marked with the [`MethodAccessFlags::Synthetic`] flag to indicate that it
    /// was generated by a compiler and does not appear in source code, unless it is one of the
    /// methods named in §4.7.8.
    ///
    /// Methods of classes may set any of the flags in Table 4.5. However, a specific method of a
    /// class may have at most one of its [`MethodAccessFlags::Private`],
    /// [`MethodAccessFlags::Protected`] and [`MethodAccessFlags::Public`] flags set (JLS
    /// §8.4.3). If a specific method has its [`MethodAccessFlags::Abstract`] flag set, it must not have any of its
    /// [`MethodAccessFlags::Final`], [`MethodAccessFlags::Native`], [`MethodAccessFlags::Private`], [`MethodAccessFlags::Static`],
    /// [`MethodAccessFlags::Strict`] or [`MethodAccessFlags::Synchronized`] flags set (JLS
    /// §8.4.3.1, JLS §8.4.3.3, JLS §8.4.3.4).
    ///
    /// All interface methods must have their [`MethodAccessFlags::Abstract`] and [`MethodAccessFlags::Public`] flags
    /// set; they may have their [`MethodAccessFlags::VarArgs`], [`MethodAccessFlags::Bridge`] and
    /// [`MethodAccessFlags::Synthetic`] flags set and must not have any of the other flags in
    /// Table 4.5 set (JLS §9.4).
    ///
    /// A specific instance initialization method (§2.9) may have at most one of its
    /// [`MethodAccessFlags::Private`], [`MethodAccessFlags::Protected`], and
    /// [`MethodAccessFlags::Public`] flags set, and may also have its
    /// [`MethodAccessFlags::Strict`], [`MethodAccessFlags::VarArgs`] and
    /// [`MethodAccessFlags::Synthetic`] flags set, but must not have any of the other flags in
    /// Table 4.5 set.
    ///
    /// Class and interface initialization methods (§2.9) are called implicitly by the Java Virtual
    /// Machine. The value of their access_flags item is ignored except for the setting of the
    /// [`MethodAccessFlags::Strict`] flag.
    ///
    /// All bits of the access_flags item not assigned in Table 4.5 are reserved for future
    /// use. They should be set to zero in generated class files and should be ignored by Java
    /// Virtual Machine implementations.
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    struct MethodAccessFlags: u16 {
        /// Declared public; may be accessed from outside its package.
        const Public = 0x0001;
        /// Declared private; accessible only within the defining class.
        const Private = 0x0002;
        /// Declared protected; may be accessed within subclasses.
        const Protected = 0x0004;
        /// Declared static.
        const Static = 0x0008;
        /// Declared final; must not be overridden (§5.4.5).
        const Final = 0x0010;
        /// Declared synchronized; invocation is wrapped by a monitor use.
        const Synchronized = 0x0020;
        /// A bridge method, generated by the compiler.
        const Bridge = 0x0040;
        /// Declared with variable number of arguments.
        const VarArgs = 0x0080;
        /// Declared native; implemented in a language other than Java.
        const Native = 0x0100;
        /// Declared abstract; no implementation is provided.
        const Abstract = 0x0400;
        /// Declared strictfp; floating-point mode is FP-strict.
        const Strict = 0x0800;
        /// Declared synthetic; not present in the source code.
        const Synthetic = 0x1000;
    }
}

#[derive(Debug, Clone)]
enum ConstantPoolInfo {
    Utf8 {
        bytes: String,
    },

    /// The [`ConstantPoolInfo::Integer`] structure represents 4-byte
    /// numeric (int) constants.
    Integer {
        /// The bytes item of the [`ConstantPoolInfo::Integer`] structure represents the value of the int
        /// constant. The bytes of the value are stored in big-endian (high byte first) order.
        bytes: u32,
    },

    /// The [`ConstantPoolInfo::Float`] structure represents 4-byte
    /// numeric (float) constants.
    Float {
        /// The bytes item of the [`ConstantPoolInfo::Float`] structure represents the value of the float
        /// constant in IEEE 754 floating-point single format (§2.3.2). The bytes of the single
        /// format representation are stored in big-endian (high byte first) order.
        ///
        /// The value represented by the [`ConstantPoolInfo::Float`] structure is determined as
        /// follows. The bytes of the value are first converted into an int constant `bits`. Then:
        ///
        /// - If `bits` is `0x7f800000`, the float value will be positive infinity.
        /// - If `bits` is `0xff800000`, the float value will be negative infinity.
        /// - If `bits` is in the range `0x7f800001`-`0x7fffffff` or in the range
        ///   `0xff800001`-`0xffffffff`, the float value will be `NaN`.
        /// - In all other cases, let s, e, and m be three values that might be computed from bits:
        ///   ```java
        ///   int s = ((bits >> 31) == 0) ? 1 : -1;
        ///   int e = ((bits >> 23) & 0xff);
        ///   int m = (e == 0) ?
        ///           (bits & 0x7fffff) << 1 :
        ///           (bits & 0x7fffff) | 0x800000;
        ///   ```
        ///   Then the float value equals the result of the mathematical expression `s * m * 2**(e-150)`.
        ///
        ///   Note(chonk): I think this is equivalent to [`f32::from_bits`] when you take care of
        ///   th edge cases
        bytes: f32,
    },
    Long {
        bytes: u64,
    },
    Double {
        bytes: f64,
    },

    /// The [`ConstantPoolInfo::Class`] structure is used to represent a class or an interface.
    Class {
        /// The value of the [`ConstantPoolInfo::Class::name_index`] item must be a valid index into the [`ClassFile::constant_pool`]
        /// table. The [`ClassFile::constant_pool`] entry at that index must be a [`ConstantPoolInfo::Utf8`] (§4.4.7)
        /// structure representing a valid binary class or interface name encoded in internal form
        /// (§4.2.1).
        name_index: u16,
    },

    /// The [`ConstantPoolInfo::String`] structure is used to represent constant objects of the
    /// type `String`:
    String {
        /// The value of the [`ConstantPoolInfo::String::string_index`] item must be a valid index
        /// into the [`ClassFile::constant_pool`] table. The [`ClassFile::constant_pool`] entry at
        /// that index must be a [`ConstantPoolInfo::Utf8`] (§4.4.7) structure representing the
        /// sequence of Unicode code points to which the String object
        /// is to be initialized.
        string_index: u16,
    },

    /// Fields, methods, and interface methods are represented by similar structures.
    Fieldref {
        /// The value of the [`ConstantPoolInfo::Fieldref::class_index`] item must be a valid index
        /// into the [`ClassFile::constant_pool`] table. The [`ClassFile::constant_pool`] entry at
        /// that index must be a [`ConstantPoolInfo::Class`] (§4.4.1) structure representing a
        /// class or interface type that has the field or method as a member.
        ///
        /// The [`ConstantPoolInfo::Fieldref::class_index`] item of a
        /// [`ConstantPoolInfo::Fieldref`] structure may be either a class type or an interface
        /// type.
        class_index: u16,

        /// The value of the [`ConstantPoolInfo::Fieldref::name_and_type_index`] item must be a
        /// valid index into the [`ClassFile::constant_pool`] table. The
        /// [`ClassFile::constant_pool`] entry at that index must be a [`ConstantPoolInfo::NameAndType`]
        /// (§4.4.6) structure. This [`ClassFile::constant_pool`] entry indicates the name and
        /// descriptor of the field or method.
        ///
        /// In a [`ConstantPoolInfo::Fieldref`], the indicated descriptor must be a field
        /// descriptor (§4.3.2). Otherwise, the indicated descriptor must be a method descriptor
        /// (§4.3.3).
        name_and_type_index: u16,
    },

    /// Fields, methods, and interface methods are represented by similar structures.
    Methodref {
        /// The value of the [`ConstantPoolInfo::Fieldref::class_index`] item must be a valid index
        /// into the [`ClassFile::constant_pool`] table. The [`ClassFile::constant_pool`] entry at
        /// that index must be a [`ConstantPoolInfo::Class`] (§4.4.1) structure representing a
        /// class or interface type that has the field or method as a member.
        ///
        /// The [`ConstantPoolInfo::Fieldref::class_index`] item of a
        /// [`ConstantPoolInfo::Fieldref`] structure may be either a class type or an interface
        /// type.
        ///
        /// The [`ConstantPoolInfo::Methodref::class_index`] item of a
        /// [`ConstantPoolInfo::Methodref`] structure must be a class type, not an interface type.
        class_index: u16,

        /// The value of the [`ConstantPoolInfo::Fieldref::name_and_type_index`] item must be a
        /// valid index into the [`ClassFile::constant_pool`] table. The
        /// [`ClassFile::constant_pool`] entry at that index must be a [`ConstantPoolInfo::NameAndType`]
        /// (§4.4.6) structure. This [`ClassFile::constant_pool`] entry indicates the name and
        /// descriptor of the field or method.
        ///
        /// If the name of the method of a [`ConstantPoolInfo::Methodref`]structure begins with a
        /// '<' ('\u003c'), then the name must be the special name `<init>`, representing an instance
        /// initialization method (§2.9). The return type of such a method must be void.
        name_and_type_index: u16,
    },
    InterfaceMethodref,

    /// The [`ConstantPoolInfo::NameAndType`] structure is used to represent a field or method,
    /// without indicating which class or interface type it belongs to:
    NameAndType {
        /// The value of the [`ConstantPoolInfo::NameAndType::name_index`] item must be a valid
        /// index into the [`ClassFile::constant_pool`] table. The [`ClassFile::constant_pool`]
        /// entry at that index must be a [`ConstantPoolInfo::Utf8`] (§4.4.7) structure
        /// representing either the special method name `<init>` (§2.9) or a valid unqualified name
        /// (§4.2.2) denoting a field or method.
        name_index: u16,

        /// The value of the [`ConstantPoolInfo::NameAndType::descriptor_index`] item must be a
        /// valid index into the [`ClassFile::constant_pool`] table. The
        /// [`ClassFile::constant_pool`] entry at that index must be a [`ConstantPoolInfo::Utf8`]
        /// (§4.4.7) structure representing a valid field descriptor (§4.3.2) or method descriptor
        /// (§4.3.3).
        descriptor_index: u16,
    },
    MethodHandle,
    MethodType,
    InvokeDynamic,
}

impl ConstantPoolInfo {
    fn parse(buf: &mut Cursor<&[u8]>) -> Self {
        let tag = read_u8_be(buf);
        match tag {
            // Utf8
            1 => {
                let length = read_u16_be(buf).into();
                let mut bytes = vec![0; length];
                buf.read_exact(&mut bytes).expect("it's a cursor");
                let str =
                    String::from_utf8(bytes).expect("TODO: parse whatever the fuck strings are");

                Self::Utf8 { bytes: str }
            }
            // Integer
            3 => Self::Integer {
                bytes: read_u32_be(buf),
            },
            // Float
            4 => Self::Float {
                bytes: read_f32_be(buf),
            },
            // Long
            5 => Self::Long {
                bytes: read_u64_be(buf),
            },
            // Double
            6 => Self::Double {
                bytes: read_f64_be(buf),
            },
            // Class
            7 => Self::Class {
                name_index: read_u16_be(buf),
            },
            // String
            8 => Self::String {
                string_index: read_u16_be(buf),
            },
            // Fieldref
            9 => {
                let class_index = read_u16_be(buf);
                let name_and_type_index = read_u16_be(buf);
                Self::Fieldref {
                    class_index,
                    name_and_type_index,
                }
            }
            // Methodref
            10 => {
                let class_index = read_u16_be(buf);
                let name_and_type_index = read_u16_be(buf);
                Self::Methodref {
                    class_index,
                    name_and_type_index,
                }
            }
            // InterfaceMethodref
            11 => todo!(),
            // NameAndType
            12 => {
                let name_index = read_u16_be(buf);
                let descriptor_index = read_u16_be(buf);
                Self::NameAndType {
                    name_index,
                    descriptor_index,
                }
            }
            // MethodHandle
            15 => todo!(),
            // MethodType
            16 => todo!(),
            // InvokeDynamic
            18 => todo!(),
            _ => panic!("invalid tag {tag}"),
        }
    }
}

#[derive(Debug, Clone)]
struct FieldInfo {}

#[derive(Debug, Clone)]
struct MethodInfo {
    access_flags: MethodAccessFlags,
    name_index: u16,
    descriptor_index: u16,
}

#[derive(Debug, Clone)]
struct AttributeInfo {}

/// The contents of a `.class` file.
///
/// The docs are mostly from
/// <https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html#jvms-4.1/>
#[derive(Debug, Clone)]
pub struct ClassFile {
    /// The magic item supplies the magic number identifying the class file format; it has the
    /// value 0xCAFEBABE.
    pub magic: u32,

    /// The values of the [`ClassFile::minor_version`] and [`ClassFile::major_version`] items are the minor and major version
    /// numbers of this class file. Together, a major and a minor version number determine the
    /// version of the class file format. If a class file has major version number M and minor
    /// version number m, we denote the version of its class file format as M.m. Thus, class file
    /// format versions may be ordered lexicographically, for example, 1.5 < 2.0 < 2.1.
    pub minor_version: u16,

    /// Refer to [`ClassFile::minor_version`] docs.
    pub major_version: u16,

    /// The value of the `constant_pool_count` item is equal to the number of entries in the
    /// [`ClassFile::constant_pool`] table plus one. A [`ClassFile::constant_pool`] index is considered valid if it is greater
    /// than zero and less than `constant_pool_count`, with the exception for constants of type long
    /// and double noted in §4.4.5.
    ///
    /// The length is u16.
    ///
    /// The [`ClassFile::constant_pool`] is a table of structures (§4.4) representing various string constants,
    /// class and interface names, field names, and other constants that are referred to within the
    /// [`ClassFile`] structure and its substructures. The format of each [`ClassFile::constant_pool`] table entry is
    /// indicated by its first "tag" byte.
    /// The [`ClassFile::constant_pool`] table is indexed from 1 to `constant_pool_count-1`.
    pub constant_pool: Vec<ConstantPoolInfo>,

    /// The value of the [`ClassFile::access_flags`] item is a mask of flags used to denote access permissions to
    /// and properties of this class or interface. The interpretation of each flag, when set, is as
    /// shown in Table 4.1.
    pub access_flags: ClassAccessFlags,

    /// The value of the `this_class` item must be a valid index into the [`ClassFile::constant_pool`] table. The
    /// [`ClassFile::constant_pool`] entry at that index must be a `CONSTANT_Class_info` structure
    /// representing the class or interface defined by this class file.
    pub this_class: u16,

    /// For a class, the value of the [`ClassFile::super_class`] item either must be zero or must be a valid index
    /// into the [`ClassFile::constant_pool`] table. If the value of the [`ClassFile::super_class`] item is nonzero, the
    /// [`ClassFile::constant_pool`] entry at that index must be a `CONSTANT_Class_info` structure
    /// representing the direct superclass of the class defined by this class file. Neither the
    /// direct superclass nor any of its superclasses may have the [`ClassAccessFlags::Final`] flag set in the
    /// [`ClassFile::access_flags`] item of its [`ClassFile`] structure.
    ///
    /// If the value of the [`ClassFile::super_class`] item is zero, then this class file must represent the class
    /// Object, the only class or interface without a direct superclass.
    ///
    /// For an interface, the value of the [`ClassFile::super_class`] item must always be a valid index into the
    /// [`ClassFile::constant_pool`] table. The [`ClassFile::constant_pool`] entry at that index
    /// must be a `CONSTANT_Class_info` structure representing the class Object.
    pub super_class: u16,

    /// The value of the `interfaces_count` item gives the number of direct superinterfaces of this
    /// class or interface type.
    ///
    /// Each value in the interfaces array must be a valid index into the [`ClassFile::constant_pool`] table. The
    /// [`ClassFile::constant_pool`] entry at each value of interfaces\[i\], where 0 ≤ i < `interfaces_count`, must be
    /// a `CONSTANT_Class_info` structure (§4.4.1) representing an interface that is a direct
    /// superinterface of this class or interface type, in the left-to-right order given in the
    /// source for the type.
    pub interfaces: Vec<u16>,

    /// The value of the `fields_count` item gives the number of [`FieldInfo`] structures in the
    /// [`ClassFile::fields`] table. The [`FieldInfo`] structures (§4.5) represent all fields, both
    /// class variables and instance variables, declared by this class or interface type.
    ///
    /// Each value in the fields table must be a [`FieldInfo`] (§4.5) structure giving a complete
    /// description of a field in this class or interface. The fields table includes only those
    /// fields that are declared by this class or interface. It does not include items representing
    /// fields that are inherited from superclasses or superinterfaces.
    pub fields: Vec<FieldInfo>,

    /// The value of the `methods_count` item gives the number of [`MethodInfo`] structures in the
    /// methods table.
    ///
    /// Each value in the methods table must be a [`MethodInfo`] (§4.6) structure giving a complete
    /// description of a method in this class or interface. If neither of the
    /// [`MethodAccessFlags::Native`] and [`MethodAccessFlags::Abstract`] flags are set in the
    /// [`MethodInfo::access_flags`] item of a [`MethodInfo`] structure, the Java Virtual Machine
    /// instructions implementing the method are also supplied.
    ///
    /// The [`MethodInfo`] structures represent all methods declared by this class or interface
    /// type, including instance methods, class methods, instance initialization methods (§2.9),
    /// and any class or interface initialization method (§2.9). The methods table does not include
    /// items representing methods that are inherited from superclasses or superinterfaces.
    pub methods: Vec<MethodInfo>,

    pub attributes: Vec<AttributeInfo>,
}

pub fn parse_class_file(class_file: &[u8]) -> ClassFile {
    let reader = &mut Cursor::new(class_file);
    let magic = read_u32_be(reader);
    println!("Magic: {magic:x}");

    let minor_version = read_u16_be(reader);
    let major_version = read_u16_be(reader);
    println!("Version {major_version}.{minor_version}");

    let mut constant_pool_count = read_u16_be(reader);
    let mut constant_pool = Vec::with_capacity(constant_pool_count.into());
    println!("There are {constant_pool_count} constants");

    for i in 0..constant_pool_count {
        let info = ConstantPoolInfo::parse(reader);
        println!("{i}: Found {info:?}");
        constant_pool.push(info);
    }

    ClassFile {
        magic,
        minor_version,
        major_version,
        constant_pool,
        access_flags: todo!(),
        this_class: todo!(),
        super_class: todo!(),
        interfaces: todo!(),
        fields: todo!(),
        methods: todo!(),
        attributes: todo!(),
    }
}
